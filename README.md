# Tugas Individu 7

1. Dalam Flutter, semua elemen tampilan adalah widget, dari hal besar seperti Scaffold sampai hal kecil seperti Text atau Icon. Widget-widget ini tersusun secara hierarkis, membentuk struktur yang disebut widget tree (pohon widget). Parent (induk) adalah widget yang membungkus widget lain. Parent mengatur layout, posisi, dan perilaku umum anak-anaknya. Child (anak) adalah widget yang dibungkus oleh parent-nya.

2. Dalam proyek ini, terdapat beberapa widget yang digunakan untuk membangun tampilan aplikasi. Widget utama yang digunakan adalah MaterialApp, yang berfungsi sebagai kerangka dasar aplikasi berbasis Material Design. Di dalamnya, terdapat widget Scaffold yang menyediakan struktur visual dasar seperti app bar, body, dan lain-lain. Selanjutnya, digunakan widget AppBar untuk menampilkan judul aplikasi di bagian atas layar. Pada bagian utama tampilan (body), digunakan widget Padding dan Column untuk mengatur tata letak elemen-elemen agar lebih rapi dan tersusun vertikal. 
Setiap menu pada halaman utama ditampilkan menggunakan widget kustom bernama ItemHomepage, yang merupakan kombinasi dari widget Card, InkWell, Icon, dan Text. Widget Card memberikan efek seperti kartu dengan bayangan halus, sementara InkWell digunakan untuk memberikan efek sentuhan saat tombol ditekan. Widget Icon digunakan untuk menampilkan simbol visual yang mewakili setiap menu, dan Text berfungsi untuk menampilkan label seperti “All Products”, “My Products”, dan “Create Product”. Semua widget ini bekerja sama membentuk tampilan interaktif dan responsif yang mengikuti gaya desain Material milik Flutter.

3. MaterialApp adalah entry point visual untuk aplikasi Flutter yang mengikuti gaya Material Design. Fungsinya yaitu Menyediakan tema global (ThemeData) untuk seluruh app, mengatur navigasi halaman (melalui routes dan Navigator), menyediakan judul dan konfigurasi dasar aplikasi. Karena itu lah MaterialApp sering dipakai sebagai root widget, karena dia membungkus semua tampilan dan memberi akses ke fitur-fitur Material Design.

4. StatelessWidget adalah jenis widget yang bersifat statis atau tidak memiliki keadaan (state) yang dapat berubah. Artinya, tampilan dan data di dalam widget ini akan tetap sama selama aplikasi berjalan, kecuali terjadi rebuild karena perubahan dari luar widget itu sendiri. Contoh penggunaannya adalah untuk elemen UI yang hanya menampilkan informasi tetap seperti teks, ikon, atau tombol dengan fungsi yang tidak bergantung pada perubahan data. Karena tidak memiliki state, StatelessWidget lebih ringan dan efisien dalam hal performa.
Sementara itu, StatefulWidget adalah widget yang dinamis dan dapat berubah sesuai interaksi pengguna atau pembaruan data. Widget jenis ini memiliki objek State yang menyimpan informasi dan dapat diperbarui menggunakan metode setState(). Contoh penggunaannya meliputi form input, counter, atau halaman yang datanya bisa berubah setelah pengguna berinteraksi. Karena harus mengelola perubahan tampilan secara terus-menerus, StatefulWidget umumnya sedikit lebih kompleks dibanding StatelessWidget dan memerlukan manajemen siklus hidup yang lebih hati-hati.
Pemilihan antara StatelessWidget dan StatefulWidget tergantung pada kebutuhan logika dan perilaku tampilan. Jika komponen hanya perlu menampilkan data statis atau tidak berubah selama aplikasi berjalan, maka StatelessWidget adalah pilihan yang tepat karena lebih sederhana dan hemat sumber daya. Namun, jika tampilan harus merespons interaksi pengguna, memperbarui data, atau menampilkan perubahan secara real-time, maka StatefulWidget lebih sesuai untuk digunakan.

5. BuildContext adalah objek yang mewakili lokasi widget di dalam widget tree. fungsinya adalah memberi akses kepada parent widget dan untuk membangun UI di metode build(BuildContext context). Tanpa BuildContext, widget tidak tahu di mana posisinya di tree dan tidak bisa mengakses parent-nya.

6. Hot reload adalah fitur di Flutter yang memungkinkan pengembang untuk melihat perubahan kode secara langsung tanpa harus menghentikan dan menjalankan ulang aplikasi. Saat hot reload dijalankan, Flutter akan menyuntikkan perubahan kode terbaru ke dalam aplikasi yang sedang berjalan, lalu memperbarui tampilan UI tanpa menghapus state (keadaan) yang sedang aktif. Hal ini membuat proses pengembangan menjadi jauh lebih cepat dan efisien karena pengembang bisa langsung melihat hasil modifikasi pada tampilan atau logika UI secara real-time tanpa kehilangan data yang sedang diuji.
Sementara itu, hot restart memiliki fungsi yang mirip namun bekerja dengan cara yang lebih mendasar. Ketika hot restart dijalankan, seluruh aplikasi akan dimulai ulang dari awal, dan semua state yang tersimpan akan dihapus. Artinya, aplikasi akan kembali ke kondisi awal seperti saat pertama kali dijalankan. Meskipun prosesnya sedikit lebih lambat dibanding hot reload, hot restart berguna saat pengembang melakukan perubahan besar pada struktur kode atau variabel global yang tidak dapat diperbarui hanya dengan hot reload.
Perbedaan utama antara keduanya terletak pada bagaimana mereka memperlakukan state. Hot reload mempertahankan keadaan yang sedang berjalan, sedangkan hot restart mengatur ulang seluruh aplikasi. Dalam praktiknya, pengembang biasanya menggunakan hot reload untuk mempercepat proses debugging atau eksperimen kecil pada tampilan, sementara hot restart digunakan ketika ada perubahan yang memengaruhi keseluruhan logika aplikasi.

# Tugas Individu 8

1. Perbedaan mendasar antara Navigator.push() dan Navigator.pushReplacement() terletak pada cara mereka memanipulasi tumpukan (stack) layar di aplikasi. Ketika menggunakan push(), layar baru ditambahkan ke atas layar saat ini, yang berarti layar sebelumnya tetap berada di tumpukan. Ini ideal untuk alur di mana pengguna diharapkan untuk kembali, misalnya saat berpindah dari halaman utama ke halaman Form Tambah Produk melalui tombol di homepage. Sebaliknya, pushReplacement() memuat layar baru sambil secara permanen menghapus layar saat ini dari tumpukan. Strategi ini sangat tepat untuk navigasi dari Drawer atau setelah login/logout, seperti yang  diterapkan saat berpindah antara Home dan Form Tambah Produk melalui drawer. Tujuannya adalah mencegah penumpukan layar yang tidak perlu, memastikan tombol back pada perangkat membawa pengguna keluar dari aplikasi atau ke layar sebelumnya yang lebih relevan, bukan kembali ke drawer yang sudah dibuka.

2. Scaffold berfungsi sebagai fondasi arsitektur untuk setiap halaman, menyediakan kerangka kerja di mana komponen lain, seperti AppBar dan Drawer, ditempatkan. AppBar menjamin bahwa setiap layar memiliki bilah judul yang seragam dan titik akses yang seragam untuk membuka Drawer. Kunci konsistensi di sini adalah penggunaan widget LeftDrawer() yang sama di seluruh aplikasi, memastikan bahwa opsi navigasi utama (Home dan Create Products) selalu terlihat sama, terlepas dari halaman mana pengguna berada. Struktur ini secara kolektif menjamin identitas visual dan pengalaman pengguna yang kohesif.

3. Dalam konteks desain antarmuka, layout widget memegang peranan krusial, terutama pada formulir. Padding digunakan untuk menciptakan ruang kosong di sekeliling setiap elemen input formulir seperti di sekeliling TextFormField untuk Nama Produk, Harga, dan Deskripsi yang secara signifikan meningkatkan keterbacaan dan mengurangi kepadatan visual. SingleChildScrollView adalah wrapper penyelamat yang Saya gunakan di sekitar seluruh formulir, fungsinya adalah membuat seluruh isi formulir dapat digulir (scrollable). Ini adalah langkah wajib untuk mencegah pixel overflow yang sering terjadi ketika keyboard muncul di layar kecil, memastikan semua elemen, termasuk tombol "Save", tetap dapat diakses.

4. Untuk menciptakan identitas visual yang konsisten dengan brand toko, penyesuaian warna tema di file main.dart adalah langkah penting. Dengan menetapkan primarySwatch: Colors.blue, Saya mendefinisikan warna utama (biru) yang kemudian secara otomatis diterapkan ke komponen seperti AppBar di seluruh aplikasi, menciptakan konsistensi tematik. Lebih lanjut, penggunaan warna fungsional yang spesifik, seperti Biru untuk "All Products", Hijau untuk "My Products" , dan Merah untuk "Create Product", membuat antarmuka tidak hanya indah tetapi juga intuitif.