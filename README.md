# Tugas Individu 7

1. Dalam Flutter, semua elemen tampilan adalah widget, dari hal besar seperti Scaffold sampai hal kecil seperti Text atau Icon. Widget-widget ini tersusun secara hierarkis, membentuk struktur yang disebut widget tree (pohon widget). Parent (induk) adalah widget yang membungkus widget lain. Parent mengatur layout, posisi, dan perilaku umum anak-anaknya. Child (anak) adalah widget yang dibungkus oleh parent-nya.

2. Dalam proyek ini, terdapat beberapa widget yang digunakan untuk membangun tampilan aplikasi. Widget utama yang digunakan adalah MaterialApp, yang berfungsi sebagai kerangka dasar aplikasi berbasis Material Design. Di dalamnya, terdapat widget Scaffold yang menyediakan struktur visual dasar seperti app bar, body, dan lain-lain. Selanjutnya, digunakan widget AppBar untuk menampilkan judul aplikasi di bagian atas layar. Pada bagian utama tampilan (body), digunakan widget Padding dan Column untuk mengatur tata letak elemen-elemen agar lebih rapi dan tersusun vertikal. 
Setiap menu pada halaman utama ditampilkan menggunakan widget kustom bernama ItemHomepage, yang merupakan kombinasi dari widget Card, InkWell, Icon, dan Text. Widget Card memberikan efek seperti kartu dengan bayangan halus, sementara InkWell digunakan untuk memberikan efek sentuhan saat tombol ditekan. Widget Icon digunakan untuk menampilkan simbol visual yang mewakili setiap menu, dan Text berfungsi untuk menampilkan label seperti “All Products”, “My Products”, dan “Create Product”. Semua widget ini bekerja sama membentuk tampilan interaktif dan responsif yang mengikuti gaya desain Material milik Flutter.

3. MaterialApp adalah entry point visual untuk aplikasi Flutter yang mengikuti gaya Material Design. Fungsinya yaitu Menyediakan tema global (ThemeData) untuk seluruh app, mengatur navigasi halaman (melalui routes dan Navigator), menyediakan judul dan konfigurasi dasar aplikasi. Karena itu lah MaterialApp sering dipakai sebagai root widget, karena dia membungkus semua tampilan dan memberi akses ke fitur-fitur Material Design.

4. StatelessWidget adalah jenis widget yang bersifat statis atau tidak memiliki keadaan (state) yang dapat berubah. Artinya, tampilan dan data di dalam widget ini akan tetap sama selama aplikasi berjalan, kecuali terjadi rebuild karena perubahan dari luar widget itu sendiri. Contoh penggunaannya adalah untuk elemen UI yang hanya menampilkan informasi tetap seperti teks, ikon, atau tombol dengan fungsi yang tidak bergantung pada perubahan data. Karena tidak memiliki state, StatelessWidget lebih ringan dan efisien dalam hal performa.
Sementara itu, StatefulWidget adalah widget yang dinamis dan dapat berubah sesuai interaksi pengguna atau pembaruan data. Widget jenis ini memiliki objek State yang menyimpan informasi dan dapat diperbarui menggunakan metode setState(). Contoh penggunaannya meliputi form input, counter, atau halaman yang datanya bisa berubah setelah pengguna berinteraksi. Karena harus mengelola perubahan tampilan secara terus-menerus, StatefulWidget umumnya sedikit lebih kompleks dibanding StatelessWidget dan memerlukan manajemen siklus hidup yang lebih hati-hati.
Pemilihan antara StatelessWidget dan StatefulWidget tergantung pada kebutuhan logika dan perilaku tampilan. Jika komponen hanya perlu menampilkan data statis atau tidak berubah selama aplikasi berjalan, maka StatelessWidget adalah pilihan yang tepat karena lebih sederhana dan hemat sumber daya. Namun, jika tampilan harus merespons interaksi pengguna, memperbarui data, atau menampilkan perubahan secara real-time, maka StatefulWidget lebih sesuai untuk digunakan.

5. BuildContext adalah objek yang mewakili lokasi widget di dalam widget tree. fungsinya adalah memberi akses kepada parent widget dan untuk membangun UI di metode build(BuildContext context). Tanpa BuildContext, widget tidak tahu di mana posisinya di tree dan tidak bisa mengakses parent-nya.

6. Hot reload adalah fitur di Flutter yang memungkinkan pengembang untuk melihat perubahan kode secara langsung tanpa harus menghentikan dan menjalankan ulang aplikasi. Saat hot reload dijalankan, Flutter akan menyuntikkan perubahan kode terbaru ke dalam aplikasi yang sedang berjalan, lalu memperbarui tampilan UI tanpa menghapus state (keadaan) yang sedang aktif. Hal ini membuat proses pengembangan menjadi jauh lebih cepat dan efisien karena pengembang bisa langsung melihat hasil modifikasi pada tampilan atau logika UI secara real-time tanpa kehilangan data yang sedang diuji.
Sementara itu, hot restart memiliki fungsi yang mirip namun bekerja dengan cara yang lebih mendasar. Ketika hot restart dijalankan, seluruh aplikasi akan dimulai ulang dari awal, dan semua state yang tersimpan akan dihapus. Artinya, aplikasi akan kembali ke kondisi awal seperti saat pertama kali dijalankan. Meskipun prosesnya sedikit lebih lambat dibanding hot reload, hot restart berguna saat pengembang melakukan perubahan besar pada struktur kode atau variabel global yang tidak dapat diperbarui hanya dengan hot reload.
Perbedaan utama antara keduanya terletak pada bagaimana mereka memperlakukan state. Hot reload mempertahankan keadaan yang sedang berjalan, sedangkan hot restart mengatur ulang seluruh aplikasi. Dalam praktiknya, pengembang biasanya menggunakan hot reload untuk mempercepat proses debugging atau eksperimen kecil pada tampilan, sementara hot restart digunakan ketika ada perubahan yang memengaruhi keseluruhan logika aplikasi.

# Tugas Individu 8

1. Perbedaan mendasar antara Navigator.push() dan Navigator.pushReplacement() terletak pada cara mereka memanipulasi tumpukan (stack) layar di aplikasi. Ketika menggunakan push(), layar baru ditambahkan ke atas layar saat ini, yang berarti layar sebelumnya tetap berada di tumpukan. Ini ideal untuk alur di mana pengguna diharapkan untuk kembali, misalnya saat berpindah dari halaman utama ke halaman Form Tambah Produk melalui tombol di homepage. Sebaliknya, pushReplacement() memuat layar baru sambil secara permanen menghapus layar saat ini dari tumpukan. Strategi ini sangat tepat untuk navigasi dari Drawer atau setelah login/logout, seperti yang  diterapkan saat berpindah antara Home dan Form Tambah Produk melalui drawer. Tujuannya adalah mencegah penumpukan layar yang tidak perlu, memastikan tombol back pada perangkat membawa pengguna keluar dari aplikasi atau ke layar sebelumnya yang lebih relevan, bukan kembali ke drawer yang sudah dibuka.

2. Scaffold berfungsi sebagai fondasi arsitektur untuk setiap halaman, menyediakan kerangka kerja di mana komponen lain, seperti AppBar dan Drawer, ditempatkan. AppBar menjamin bahwa setiap layar memiliki bilah judul yang seragam dan titik akses yang seragam untuk membuka Drawer. Kunci konsistensi di sini adalah penggunaan widget LeftDrawer() yang sama di seluruh aplikasi, memastikan bahwa opsi navigasi utama (Home dan Create Products) selalu terlihat sama, terlepas dari halaman mana pengguna berada. Struktur ini secara kolektif menjamin identitas visual dan pengalaman pengguna yang kohesif.

3. Dalam konteks desain antarmuka, layout widget memegang peranan krusial, terutama pada formulir. Padding digunakan untuk menciptakan ruang kosong di sekeliling setiap elemen input formulir seperti di sekeliling TextFormField untuk Nama Produk, Harga, dan Deskripsi yang secara signifikan meningkatkan keterbacaan dan mengurangi kepadatan visual. SingleChildScrollView adalah wrapper penyelamat yang Saya gunakan di sekitar seluruh formulir, fungsinya adalah membuat seluruh isi formulir dapat digulir (scrollable). Ini adalah langkah wajib untuk mencegah pixel overflow yang sering terjadi ketika keyboard muncul di layar kecil, memastikan semua elemen, termasuk tombol "Save", tetap dapat diakses.

4. Untuk menciptakan identitas visual yang konsisten dengan brand toko, penyesuaian warna tema di file main.dart adalah langkah penting. Dengan menetapkan primarySwatch: Colors.blue, Saya mendefinisikan warna utama (biru) yang kemudian secara otomatis diterapkan ke komponen seperti AppBar di seluruh aplikasi, menciptakan konsistensi tematik. Lebih lanjut, penggunaan warna fungsional yang spesifik, seperti Biru untuk "All Products", Hijau untuk "My Products" , dan Merah untuk "Create Product", membuat antarmuka tidak hanya indah tetapi juga intuitif.

# Tugas Individu 9

1. Dalam proses komunikasi antara Flutter dan Django, data dikirimkan dan diterima dalam format JSON yang harus didekodekan menjadi struktur data Dart. Pembuatan model Dart menjadi langkah penting karena model tersebut berfungsi sebagai representasi terstruktur dari data yang digunakan, sekaligus menjadi kontrak tipe yang memastikan konsistensi antara server dan aplikasi klien. Tanpa model, pemetaan langsung ke Map<String, dynamic> menyebabkan berkurangnya keamanan tipe dan null safety, mengharuskan pengembang melakukan konversi tipe secara manual pada setiap akses field. Hal ini sangat rentan terhadap kesalahan, terutama ketika server mengirimkan tipe data yang tidak sesuai atau ketika suatu atribut bernilai null, yang dapat berujung pada kegagalan runtime. Selain itu, tanpa model, upaya pemeliharaan kode menjadi jauh lebih sulit karena perubahan nama field pada sisi Django mengharuskan pembaruan secara menyeluruh pada berbagai bagian aplikasi. Dengan menggunakan model Dart, seluruh perubahan dapat dikonsolidasikan pada satu fungsi parsing sehingga konsistensi dan keberlangsungan kode akan tetap terjaga.

2. Paket http dan CookieRequest memiliki fungsi yang berbeda meskipun keduanya digunakan dalam komunikasi antara Flutter dan Django. Paket http bertindak sebagai pustaka dasar yang menyediakan kemampuan untuk melakukan permintaan HTTP seperti GET dan POST. Namun, paket ini bersifat stateless sehingga tidak dapat menyimpan informasi sesi atau cookie dari permintaan sebelumnya. Sebaliknya, CookieRequest berfungsi sebagai pembungkus yang memungkinkan komunikasi bersifat stateful. Paket ini mampu menangkap serta menyimpan cookie yang dikirim oleh Django, seperti sessionid dan csrftoken, kemudian melampirkannya kembali pada seluruh permintaan berikutnya. Dengan demikian, CookieRequest memungkinkan sistem autentikasi berbasis sesi Django berfungsi dengan benar pada aplikasi Flutter tanpa memerlukan pengelolaan cookie secara manual.

3. Instance CookieRequest harus dibagikan secara konsisten ke seluruh komponen aplikasi karena instance tersebut menyimpan status autentikasi pengguna, termasuk cookie sesi yang diperlukan untuk mengakses endpoint Django yang bersifat privat. Apabila setiap halaman aplikasi membuat instance baru, instance tersebut tidak akan memiliki cookie yang tersimpan sehingga Django akan menganggap setiap permintaan berasal dari pengguna anonim. Dengan memastikan bahwa satu instance dibagikan melalui mekanisme seperti Provider, seluruh permintaan yang dilakukan oleh aplikasi akan membawa konteks autentikasi yang sama, sehingga pengguna tetap dianggap berada dalam sesi yang valid di seluruh alur navigasi aplikasi.

4. Agar aplikasi Flutter dapat berkomunikasi dengan Django, diperlukan sejumlah konfigurasi penting baik pada server maupun aplikasi klien. Django perlu mencantumkan alamat 10.0.2.2 dalam variabel ALLOWED_HOSTS karena Android Emulator menggunakan alamat tersebut untuk mengakses komputer host. Tanpa konfigurasi ini, Django akan menolak permintaan dan menampilkan kesalahan terkait header host yang tidak valid. Selain itu, Django harus mengaktifkan CORS menggunakan django-cors-headers karena Flutter dan Django berjalan pada origin yang berbeda, sehingga tanpa CORS permintaan lintas origin akan diblokir. Django juga perlu menyesuaikan pengaturan cookie, terutama pada aspek SameSite dan keamanan token, agar session cookie yang dikirim Django dapat diterima dan digunakan kembali oleh Flutter tanpa terhalang pembatasan lintas domain. Pada sisi Android, konfigurasi izin akses internet harus ditambahkan ke dalam AndroidManifest.xml agar aplikasi memiliki hak untuk melakukan koneksi ke server. Jika salah satu dari konfigurasi tersebut tidak diterapkan dengan benar, aplikasi dapat gagal memuat data, gagal melakukan autentikasi, atau bahkan tidak dapat melakukan koneksi sama sekali.

5. Proses pengiriman data dari Flutter ke Django hingga data tersebut kembali ditampilkan pada aplikasi berlangsung melalui sejumlah tahapan yang saling berkesinambungan. Ketika pengguna mengisi formulir pada Flutter, data yang diperoleh dari controller diubah menjadi sebuah struktur Map dan kemudian diserialisasi menjadi JSON. Data ini dikirimkan ke Django menggunakan permintaan POST melalui CookieRequest, dengan menyertakan cookie sesi yang relevan. Django kemudian menerima dan memproses data tersebut dengan melakukan parsing JSON dan validasi nilai. Data yang valid disimpan sebagai entitas baru di database dan Django mengembalikan respons yang menunjukkan keberhasilan proses. Setelah menerima respons ini, Flutter mengeksekusi navigasi kembali atau memperbarui tampilan. Ketika halaman daftar produk ditampilkan, Flutter kembali melakukan permintaan GET untuk mengambil data terbaru dari Django, mendeserialisasi JSON yang diterima menjadi objek model Dart, kemudian menampilkannya pada antarmuka pengguna melalui elemen-elemen widget yang sesuai. Dengan demikian, seluruh alur, dari input hingga tampilan, berlangsung melalui integrasi antara proses serialisasi, komunikasi jaringan, validasi server, dan deserialisasi.

6. Autentikasi antara Flutter dan Django menggunakan pendekatan session-based authentication sepenuhnya. Pada proses pendaftaran, Flutter mengirimkan data akun ke Django, di mana Django memverifikasi validitas data dan membuat entri pengguna baru di database. Setelah pendaftaran berhasil, Flutter mengarahkan pengguna menuju halaman login. Pada proses login, Flutter mengirimkan kredensial melalui permintaan POST ke endpoint login Django. Django memverifikasi kredensial menggunakan fungsi autentikasi internal, dan apabila data valid, Django membuat sesi baru dan mengirimkan cookie berisi sessionid kepada Flutter. Cookie ini kemudian disimpan oleh CookieRequest dan digunakan pada seluruh permintaan berikutnya. Setelah berhasil login, pengguna diarahkan ke halaman utama aplikasi. Sementara itu, proses logout diawali oleh permintaan dari Flutter ke endpoint logout Django. Django kemudian menghapus sesi pengguna pada server, dan Flutter melalui CookieRequest menghapus cookie yang tersimpan. Sebagai hasilnya, pengguna diarahkan kembali ke halaman login dan kehilangan akses ke konten yang membutuhkan autentikasi. Keseluruhan alur ini memastikan bahwa autentikasi berlangsung secara aman dan konsisten sesuai standar manajemen sesi Django.

7. Tahap pertama berfokus pada persiapan backend dan proses deployment agar Django siap melayani permintaan dari Flutter, termasuk dari Android Emulator. Pada tahap ini, dilakukan verifikasi terhadap konfigurasi settings.py, khususnya bagian ALLOWED_HOSTS, untuk memastikan bahwa 10.0.2.2 sebagai IP khusus emulator Android, localhost, serta domain deployment seperti PWS atau Vercel telah tercantum. Selain itu, dipastikan bahwa corsheaders telah diinstal dan dikonfigurasi dengan benar sehingga API Django dapat diakses dari Flutter tanpa mengalami pemblokiran. Pada sisi endpoint, terdapat dua fungsi berbeda dalam main/views.py, yaitu show_json yang mengembalikan data berdasarkan pengguna yang sedang login menggunakan Product.objects.filter(user=request.user), serta show_json_all yang mengembalikan seluruh produk melalui Product.objects.all(). Kedua fungsi tersebut didaftarkan pada main/urls.py melalui rute /json/ dan /json-all/ untuk memenuhi kebutuhan fitur filter by logged-in user dan daftar semua item. Tahap kedua berfokus pada integrasi autentikasi antara Django dan Flutter agar aplikasi mampu menyimpan status login menggunakan mekanisme sesi Django. Pada tahap ini, dipastikan bahwa paket provider dan pbp_django_auth telah ditambahkan ke dalam pubspec.yaml. Selanjutnya, file main.dart dikonfigurasi dengan membungkus MaterialApp menggunakan Provider yang menyediakan instance CookieRequest. Konfigurasi ini sangat penting karena instance tersebut menyimpan cookie sesi dan harus dapat digunakan secara bersama-sama oleh halaman Login, Register, dan daftar produk. Tahap ketiga adalah pembuatan model kustom untuk menerjemahkan data JSON yang dikirimkan Django menjadi objek Dart. Proses dimulai dengan menganalisis struktur JSON yang berisi atribut seperti name, price, description, thumbnail, category, dan is_featured. Berdasarkan analisis tersebut, dibuat file product_entry.dart di direktori lib/models/. File ini memuat kelas ProductEntry lengkap dengan metode fromJson dan toJson, baik ditulis manual maupun dihasilkan menggunakan layanan seperti Quicktype. Tujuan utamanya adalah agar setiap data yang diterima dari JSON memiliki tipe yang tepat, seperti memastikan bahwa price benar-benar ditangani sebagai int dan tidak menyebabkan kesalahan tipe. Tahap keempat adalah implementasi fitur login dan register agar pengguna dapat mengakses data privat setelah berhasil masuk ke sistem. Pada halaman register di screens/register.dart, dibuat formulir input untuk username dan password. Ketika formulir dikirim, data dikirimkan ke Django melalui request.post menuju endpoint /auth/register/, dan jika pendaftaran berhasil, pengguna diarahkan ke halaman login. Pada halaman login (screens/login.dart), prosesnya serupa, tetapi menggunakan request.login menuju endpoint /auth/login/. Fungsi login ini secara otomatis menyimpan cookie sesi jika autentikasi berhasil, kemudian mengarahkan pengguna menuju halaman Menu. Tahap kelima mencakup pembuatan halaman daftar item serta mekanisme filtering antara “semua item” dan “item milik pengguna”. Pada halaman daftar yang dibuat sebagai ProductEntryPage di screens/products_entry_list.dart, ditambahkan parameter endpointUrl agar halaman ini dapat digunakan untuk dua kebutuhan sekaligus. Pengambilan data dilakukan dengan FutureBuilder yang memanggil request.get(endpointUrl), kemudian output JSON diubah menjadi objek model Dart menggunakan ProductEntry. Data yang telah diproses ditampilkan dalam bentuk kartu berisi name, price, description, dan category, termasuk koreksi pada tampilan harga. Pada bagian drawer (widgets/left_drawer.dart), ditambahkan dua navigasi menuju daftar semua item menggunakan /json-all/ dan daftar item pengguna menggunakan /json/, yang memenuhi kriteria filtering berdasarkan pengguna yang sedang login. Tahap keenam melibatkan pembuatan halaman detail item di screens/product_detail.dart untuk menampilkan informasi lengkap satu produk. Halaman ini menerima parameter berupa objek ProductEntry dan menampilkan seluruh atribut seperti name, price, description, category, thumbnail, serta is_featured. Format harga dikoreksi agar menggunakan awalan “Rp” sesuai standar penulisan mata uang. Navigasi kembali tersedia melalui tombol back default dari AppBar maupun tombol tambahan menggunakan Navigator.pop(context). Tahap ketujuh adalah penghubung antarhalaman, khususnya antara daftar item dan detail item. Pada screens/products_entry_list.dart, setiap kartu item dibungkus dengan InkWell atau GestureDetector, kemudian pada aksi onTap dilakukan navigasi menuju ProductDetailPage sambil membawa objek ProductEntry yang dipilih. Dengan demikian, seluruh mekanisme mulai dari backend, autentikasi, pengolahan data, hingga tampilan dan navigasi telah terintegrasi secara menyeluruh dalam aplikasi Flutter.